# Accessing Data with MySQL
Based on this[Spring Guide](https://spring.io/guides/gs/accessing-data-mysql/)
This project walks thru the process of creating a Spring application connected with a MySQL Database (as opposed to a in-memory, embedded database) using Spring Data JPA to access the database. 

### Steps Taken to Create The Project
1. Create a new Gradle Project via IntelliJ & add dependencies within build.gradle

2. Set up the database
    - create the database
    - create the user and password for that user
    - set privileges on that user
```
mysql> create database db_example; -- Create the new database
mysql> create user 'springuser'@'localhost' identified by 'ThePassword'; -- Creates the user
mysql> grant all on db_example.* to 'springuser'@'localhost'; -- Gives all the privileges to the new user on the newly created database
```
    
3. Define Connection Attributes in ```application.properties```
    - Spring Boot gives you defaults on all things, the default in database is H2, so when you want to change this and use any other database you must define the connection attributes in the application.properties file.
    - Define the spring.datasource properties and the hibernate privileges
        ```
            spring.jpa.hibernate.ddl-auto=create
            spring.datasource.url=jdbc:mysql://localhost:3306/db_example
            spring.datasource.username=springuser
            spring.datasource.password=ThePassword
        ```
    - Note: spring.jpa.hibernate.ddl-auto can be none, update, create, create-drop
        - none: the default for MySQL, no change to the database structure; this is the default for MySQL
        - update: Hibernate changes the database according to the given Entity structures.
        - create: Creates the database every time, but donâ€™t drop it when close.
        - create-drop Creates the database then drops it when the SessionFactory closes; this is the default for H2 and other embedded db's
    - Begin with create because the database structure isn't set up yet. After the first run, can switch to update or none.

4. Create the @Entity Model with a User.java POJO
This is the entity class which Hibernate will automatically translate into a table.

5. Create the repository
    - Create the repository as an interface
    - The interface will be automatically implemented by Spring into a bean called userRepository (same name but diff case)

6. Create a controller for your Spring Application

7. Make the application executable via 'Application' class

8. Run the application and test the database
    - add an entry to the db & retrieve it to test the db
 
9. Secure the Application
To protect against SQL injection attacks, in which a hacker may inject DROP TABLE or any other destructive SQL commands, restrict privileges on the db 

It is good security practice that after your database is in production state:
- to set the privileges to none and revoke all privileges from the MySQL user connected to the Spring application
- then give the app only SELECT, UPDATE, INSERT, DELETE.

    1. Revoke ALL the priviliges from the user associated with the Spring application, so the app can't do anything in the database.
    ```mysql> revoke all on db_example.* from 'springuser'@'localhost';```
    
    2. Give your Spring app only the privileges necessary to make changes to only the data of the database and not the structure (schema).                        
    ```mysql> grant select, insert, delete, update on db_example.* to 'springuser'@'localhost';```
    
    3. Make this change to your application.properties file
    ```spring.jpa.hibernate.ddl-auto=none```
    
When you want to make changes on the database:
- regrant the permissions
- change the spring.jpa.hibernate.ddl-auto to update
- re-run your applications
- then repeat. 

Or... use a dedicated migration tool such as Flyway or Liquibase.


### Annotations
#### User.java
1. @Entity - tells Hibernate to make a table out of this class

#### MainController.java
1. @Controller: used to indicate the class is a Spring controller.
2. @RequestMapping(path="/demo") 
    - Sets up URL's start with /demo (after Application path)
    - @RequestMapping maps all HTTP operations by default
3. @Autowired
    - Creates a bean called userRepository, which is auto-generated by Spring 
    - This bean will be used to handle the data
3. @GetMapping(path="/add")
    - A shortcut for @RequestMapping(method=GET)
    - Maps only GET requests 
4. @ResponseBody: indicates that the returned String is the response, not a view name
5. @RequestParam: 
    - indicates that this is a parameter from the GET or POST request
    - used bind the parameter values from query string

